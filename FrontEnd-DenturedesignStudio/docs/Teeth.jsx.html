<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: Teeth.jsx</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Teeth.jsx</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * @section Teeth
 * 
 * @description This component renders a visual representation of teeth and allows users to interact with it
 * to select missing teeth, add rests, retentions, clasps, plates, undercuts, and gingival components
 * for a dental prosthesis design.
 * 
 * @param {Object} props - The properties passed to the component.
 * @param {function} props.setMissingtooth - Function to handle the selection of missing teeth.
 * @param {function} props.selectRest - Function to handle the selection of rests.
 * @param {function} props.selectRetention - Function to handle the selection of retentions.
 * @param {function} props.addIndirectretention - Function to handle adding indirect retentions.
 * @param {function} props.selectPlate - Function to handle the selection of plates.
 * @param {function} props.selectClasp - Function to handle the selection of clasps.
 * @param {Object} props.DentureData - Contains the denture design data including missing teeth, retention, rests, clasps, plates, and more.
 * @param {function} props.setData - Function to update the denture design data.
 */

import React, { useEffect, useState } from "react";
import { ToastContainer, toast, Bounce } from "react-toastify";
import "react-toastify/dist/ReactToastify.css";
import "./Teeth.css";
import "./Plate.css";
import "./Undercut.css";
import "./Rest.css";
import "./RetentionUp.css";
import "./RetentionDown.css";
import "./Retentionring.css";
import "./claspUp.css";
import "./claspDown.css";
import "./Gingivally.css";
import "./MissingTeeth.css";

import TeethImages from "./Teethimages";
import { RestImages, occlusal, cingulam, incisal } from "./Restimages";
import PlateImages from "./PlatesImages";
import UndercutsImages from "./Undercutimages";
import gingivallyImages from "./gingivallyImages";

import {
  RetentionUpImages,
  Ring,
  Circumferential,
  RetentionDownImages,
  RetentionRingImages,
} from "./RetentionImages";

import { ClaspUpImages, ClaspDownImages } from "./Claspsimages";

import MissingTeethImages from "./MissingTeethImages";

const Teeth = ({
  disableSelection,
  value,
  setMissingtooth,
  selectRest,
  selectRetention,
  addIndirectretention,
  DentureData,
  setData,
  selectPlate,
  selectClasp,
}) => {
   // Tracks the selected retention state, including up, down, and ring clasps
  const [selectedRetention, setSelectedRetention] = useState(
    DentureData.retentiondata
      ? DentureData.retentiondata
      : {
          upClasp: Array(36).fill(false),
          downClasp: Array(36).fill(false),
          ringClasp: Array(16).fill(false),
        }
  );

   // Tracks the selected clasps of Reciprocations (up and down)
  const [selectedClasps, setSelectedClasp] = useState(
    DentureData.clasps
      ? DentureData.clasps
      : { upClasp1: Array(36).fill(false), downClasp1: Array(36).fill(false) }
  );

  // Tracks the selected missing teeth
  const [selectedTeeth, setSelectedTeeth] = useState(
    DentureData.missingteeth ? DentureData.missingteeth : Array(32).fill(false)
  );

  // Tracks the selection of gingivally element of the retentions
  const [selectedGingivally, setSelectedGingivally] = useState(
    DentureData.gingivally ? DentureData.gingivally : Array(36).fill(false)
  );

  // Tracks which buttons were clicked first
  const [firstbuttoncliked, setfirstbuttoncliked] = useState(
    Array(32).fill(false)
  );

   // Tracks the selected rests for each tooth
  const [selectedRests, setSelectedRests] = useState(
    DentureData.restdata ? DentureData.restdata : Array(62).fill(false)
  );

   // Tracks the selected plates in the design
  const [selectedPlates, setSelectedPlates] = useState(
    DentureData.plates ? DentureData.plates : Array(40).fill(false)
  );

  // Tracks the selected undercuts for the design
  const [selectedUnderCut, setSelectedUndercut] = useState(
    DentureData.undercuts ? DentureData.undercuts : Array(20).fill(false)
  );

  // Tracks whether a rest is currently being selected
  const [isRestselect, setRestselect] = useState(false);

  // Controls the z-index for rendering components
  const [zindex, setZindex] = useState({ up: 4, down: 4, ring: 4 });

  // Tracks the selected teeth by rest type
  const [selectedTeethbyRest, setselectedTeethbyRest] = useState(null);
  
  console.log(selectedTeeth);
  const RestIndex = {
    1: [null, 1],
    2: [2, 3],
    3: [4, 5],
    4: [6, 7],
    5: [8, 9],
    12: [10, 11],
    13: [12, 13],
    14: [14, 15],
    15: [16, 17],
    16: [null, 18],
    17: [19],
    18: [20, 21],
    19: [22, 23],
    20: [24, 25],
    21: [26, 27],
    28: [28, 29],
    29: [30, 31],
    30: [32, 33],
    31: [34, 35],
    32: [36],
    6: [37, 38, 39],
    11: [40, 41, 42],
    22: [43, 44, 45],
    27: [46, 47, 48],
    7: [49],
    8: [50, 57, 58, 59],
    9: [51, 60, 61, 62],
    10: [52],
    23: [53],
    24: [54],
    25: [55],
    26: [56],
  };

  /**
 * @subsection Handles clicking on a tooth to toggle its selection as missing.
 * Updates the state to reflect which teeth are selected as missing.
 * 
 * @param {number} index - The index of the tooth being clicked.
 */
  
  const handleToothClick = (index) => {
    if (setMissingtooth) {
      setSelectedTeeth((prevState) => {
        const newState = [...prevState];
        newState[index] = !newState[index];

        if (setMissingtooth) {
          console.log(`Missing Teeth, selected Tooth ${index + 1}`);
        } else {
          console.log(`Selected Tooth ${index + 1}`);
        }

        // Log each tooth's state

        return newState;
      });
    }
  };

  const selectedTeethIndices = selectedTeeth
    .map((isSelected, index) => (isSelected ? index : null))
    .filter((index) => index !== null);

  
  /**
  * @subsection 
  * 
  * Handles clicking on a rest to toggle its selection.
  * Ensures that the rest matches the selected rest type (occlusal, incisal, or cingulam) and
  * prevents adding rests to missing teeth.
  * 
  * @param {number} index - The index of the rest being clicked.
  */

    const handleRestClick = (index) => {
    if (!disableSelection) {
      setSelectedRests((prevState) => {
        const newState = [...prevState];


        // Get the rest image based on the index
        const restImage = RestImages[index];

        // Check if the selected rest type matches the rest image
        const restTypeMatches =
          (selectRest.restType === occlusal.type &amp;&amp;
            occlusal.array.includes(restImage)) ||
          (selectRest.restType === incisal.type &amp;&amp;
            incisal.array.includes(restImage)) ||
          (selectRest.restType === cingulam.type &amp;&amp;
            cingulam.array.includes(restImage));

        // Check if the rest is being added to a missing tooth
        const isOnMissingTeeth = selectedTeethIndices.some((teethIndex) =>
          RestIndex[teethIndex + 1]?.includes(index + 1)
        );

        // Toggle selection if the rest type matches and the tooth is not missing
        if (restTypeMatches &amp;&amp; !isOnMissingTeeth) {
          
          // Toggle selection if the rest type matches
          newState[index] = !newState[index];
        } else {

          // Show error if the rest type doesn't match
          if (selectRest.restType &amp;&amp; !isOnMissingTeeth) {
            toast.error(
              "Error: You can only select " + selectRest.restType + " rests."
            );
          }
          if (isOnMissingTeeth &amp;&amp; selectRest.restType) {
            toast.error("Error: You cannot select a rest on a missing tooth.");
          }
        }

        return newState;
      });
    }
  };

  /**
  * useEffect Hook to update DentureData state when selections change.
  * 
  * This effect runs every time one of the following states is updated:
  * - `selectedRests`: Stores the selected rest data for teeth.
  * - `selectedRetention`: Stores the selected retention data for teeth.
  * - `selectedTeeth`: Tracks which teeth are selected or marked as missing.
  * - `selectedUnderCut`: Stores the selected undercut data for teeth.
  * - `selectedPlates`: Tracks the selected plates for the denture.
  * - `selectedClasps`: Tracks the selected clasps for the teeth.
  * - `selectedGingivally`: Stores the gingivally selected components.
  *
  * The purpose of this `useEffect` is to gather all these selected states 
  * and update the `DentureData` object with the current state of all selections.
  * It allows the component to pass the updated denture design data to other components
  * or logic that rely on this consolidated state.
  *
  * Dependencies: 
  * This effect depends on the changes in `selectedRests`, `selectedRetention`, `selectedTeeth`, 
  * `selectedUnderCut`, `selectedPlates`, `selectedClasps`, and `selectedGingivally`.
  * When any of these states change, `setData` is triggered to update the main data object.
  */

  useEffect(() => {
    setData({
      rests: selectedRests,
      retentions: selectedRetention,
      teeths: selectedTeeth,
      undercuts: selectedUnderCut,
      plates: selectedPlates,
      clasps: selectedClasps,
      gingivally: selectedGingivally,
    });
  }, [
    selectedRests,
    selectedTeeth,
    selectedUnderCut,
    selectedRetention,
    selectedPlates,
    selectedClasps,
    selectedGingivally,
  ]);


  /**
  * Handles the click event for selecting or deselecting an undercut for a given tooth.
  * 
  * @param {number} index - The index of the undercut being clicked.
  * 
  * The function toggles the selected state of the undercut at the given index.
  * If `disableSelection` is false, it updates the state to either select or deselect
  * the undercut for the specified tooth.
  */

  const handleUndercutClick = (index) => {
    if (!disableSelection) {
      setSelectedUndercut((prevState) => {
        const newState = [...prevState];
        newState[index] = !newState[index];
        return newState;
      });
    }
  };



  /**
  * Handles the click event for selecting or deselecting gingivally retention on a tooth.
  * 
  * @param {number} index - The index of the gingival retention being clicked.
  * 
  * This function toggles the gingivally selection for the given tooth, but only if:
  * - The tooth is not missing.
  * - There is no undercut on the opposite side of the tooth.
  * 
  * It performs different checks based on the tooth index to determine which side
  * the retention is being added and ensures that the undercut is present on the correct side.
  * 
  * If any condition fails, it displays an error using the `toast` library.
  */

  const handleGingivallyClick = (index) => {
    setSelectedGingivally((prevState) => {
      const newState = [...prevState];
      console.log("gingival index", index);
      if (index &lt; 8 || (index > 15 &amp;&amp; 24)) {
        const undercutpresent = (index) =>
          selectedUnderCut[index + (index &lt; 5 ? 1 : index &lt; 21 ? 5 : 11)] !==
          true;

        if (!selectedTeeth[index + 1] &amp;&amp; undercutpresent(index)) {
          newState[index] = !newState[index];
        } else {
          toast.error(
            selectedTeeth[index + 1]
              ? "Error: You cannot add a gingivally retention to missing teeth."
              : "Error: You cannot add a gingivally retention to this teeth. Undercut is not in this side"
          );
        }
      } else {
        const undercutpresent = (index) =>
          selectedUnderCut[index - (index &lt; 5 ? 1 : index &lt; 21 ? 7 : 13)] !==
          true;

        if (!selectedTeeth[index - 1] &amp;&amp; undercutpresent(index)) {
          newState[index] = !newState[index];
        } else {
          toast.error(
            selectedTeeth[index - 1]
              ? "Error: You cannot add a gingivally retention to missing teeth."
              : "Error: You cannot add a gingivally retention to this teeth. Undercut is not in this side"
          );
        }
      }

      return newState;
    });
  };


  /**
  * Handles the click event for the first button to add gingivally retention.
  * 
  * @param {number} index - The index of the tooth being selected.
  * 
  * This function checks whether the tooth is missing before allowing the addition 
  * of gingivally retention only if the tooth is not missing. 
  * Otherwise it displays an error message.
  */

  const handlefirstButton = (index) => {
    setfirstbuttoncliked((prevState) => {
      const newState = [...prevState];
      if (selectedTeeth[index]) {
        newState[index] = !newState[index];
      } else {
        toast.error(
          "Error: You cannot add a gingivally retention to this teeth."
        );
      }

      return newState;
    });
  };


  /**
  * Handles the click event for selecting or deselecting a plate on a given tooth.
  * 
  * @param {number} index - The index of the plate being clicked.
  * 
  * The function first adjusts the `index` to match the plate layout (based on upper or lower arch).
  * To add a plate
  *   - tooth should not be missing
  *   - undercut should be on the opposite side of the plate
  * If the conditions are not met, it displays relevant error messages.
  */

  const handlePlateClick = (index) => {
    const adjustedIndex = (() => {
      if (index &lt; 5 || (index > 19 &amp;&amp; index &lt; 25))
        return index &lt; 5 ? index : index - 20;
      if ((index &lt; 10 &amp;&amp; index > 4) || (index > 24 &amp;&amp; index &lt; 30))
        return index &lt; 10 ? index + 6 : index - 14;
      if ((index &lt; 15 &amp;&amp; index > 9) || (index > 29 &amp;&amp; index &lt; 35))
        return index &lt; 15 ? index + 6 : index - 14;
      if ((index &lt; 20 &amp;&amp; index > 14) || (index > 34 &amp;&amp; index &lt; 40))
        return index &lt; 20 ? index + 12 : index - 8;
      return null;
    })();

    if (adjustedIndex !== null) {
      if (!selectedTeeth[adjustedIndex]) {
        setSelectedPlates((prevState) => {
          const newState = [...prevState];
          const isUpperPlate = index &lt; 20;
          const underCutIndex = isUpperPlate ? index : index - 20;
          const isUnderCut = selectedUnderCut[underCutIndex];

          if ((isUpperPlate &amp;&amp; !isUnderCut) || (!isUpperPlate &amp;&amp; isUnderCut)) {
            newState[index] = !newState[index];
          } else {
            toast.error(
              isUpperPlate
                ? "Error: you cannot add plate this side"
                : "Error: this side is under cut"
            );
          }

          return newState;
        });
      } else {
        toast.error("Error:can not add plates to a missing teeth");
      }
    }
  };

  /**
  * Finds the index of the selected rest and applies necessary conditions for occlusallyType retentions.
  * 
  * @param {number} Index - The index of the tooth being processed.
  * 
  * The function iterates over the `RestIndex` object to check if the given `Index + 1` exists in any of its arrays.
  * 
  * - If the rest is found in the array (its index is not -1), it checks if the rest is on a valid tooth for a ring clasp.
  * - If the selected occlusallyType is "ring" and the rest is on an invalid tooth, it shows an error message.
  * - It updates the z-index depending on the type of retention (ringType or circumferential) and the position of the rest (up or down).
  * - In addition if the user is editing either the clasp or the plate, it updates the z-index accordingly.
  * 
  * If none of the conditions are satisfied, the function breaks out of the loop.
  */
  
  const findIndexInArray = (Index) => {
    for (const [key, array] of Object.entries(RestIndex)) {
      const index = array.indexOf(Index + 1);

      // Teeth positions where a ring clasp is valid
      const ringteeth = [1, 2, 15, 16, 17, 18, 31, 32];

      // Check if the key is in the valid range of teeth
      if (
        (key > 0 &amp;&amp; key &lt; 6) || // upper left molars + pre molars
        (key > 11 &amp;&amp; key &lt; 22) || // upper right and lower right molars + pre molars
        (key > 27 &amp;&amp; key &lt; 33) // lower left molars + pre molars
      ) {
        if (index !== -1) {
          // Check if the key is in ringteeth
          const isKeyInRingteeth = ringteeth.includes(Number(key));

          // Condition for showing the error
          if (
            (index === 0 &amp;&amp;
              !isKeyInRingteeth &amp;&amp;
              selectRetention.occlusallyType === "ring") ||
            (index === 1 &amp;&amp;
              !isKeyInRingteeth &amp;&amp;
              selectRetention.occlusallyType === "ring")
          ) {
            toast.error("Error: you can't add ring clasp for this rest");
            break;
          }
           // Handle z-index based on retentionType
          if (selectRetention.retentionType) {
            index === 0
              ? setZindex({
                  up: 7,
                  down:
                    selectRetention.occlusallyType === "circumferential"
                      ? 9
                      : 8,
                  ring: selectRetention.occlusallyType === "ring" ? 9 : 8,
                })
              : setZindex({
                  up:
                    selectRetention.occlusallyType === "circumferential"
                      ? 9
                      : 8,
                  ring: selectRetention.occlusallyType === "ring" ? 9 : 8,
                  down: 7,
                });
          }

          // Handle z-index when editing a clasp or plate
          if (selectClasp.edit || selectPlate.edit) {
            console.log("clicked");
            index === 0
              ? setZindex({ up: 7, down: 9 })
              : setZindex({ up: 9, down: 7 });
          }
          setselectedTeethbyRest(key - 1);
        }
      }
    }

    // Return -1 if the value is not found (implicit return if the function doesn't find the rest)
  };


 /**
 * Handles the logic for selecting a retention (up, down, or ring) for a specific tooth.
 * Ensures that the retention is added to the correct side, on the correct tooth, and under the right conditions.
 * 
 * @param {number} index - The index of the tooth being processed.
 * @param {string} UporDown - A string indicating if the retention is added "up", "down", or "ring".
 * 
 * The function performs the following checks:
 * - Determines the correct retention image based on the direction (up, down, or ring).
 * - Validates the correct side of the undercut for the retention.
 * - Ensures the retention is added to a valid tooth position.
 * - Prevents ring clasp addition to teeth where it is not allowed.
 * - Toggles the retention visibility if all conditions are met, or provides error messages if not.
 */
const handleRetentionClick = (index, UporDown) => {
  setSelectedRetention((prevState) => {
    const newState = { ...prevState };

    // Select the appropriate image based on the direction (up, down, ring)
    const retentionImage =
      UporDown === "up"
        ? RetentionUpImages[index]
        : UporDown === "down"
        ? RetentionDownImages[index]
        : RetentionRingImages[index];

    // Select the appropriate retention array (upClasp, downClasp, ringClasp)
    const retentionArray =
      UporDown === "up"
        ? newState.upClasp
        : UporDown === "down"
        ? newState.downClasp
        : newState.ringClasp;

    // Calculate adjusted index based on the retention direction
    const adjustIndex = (() => {
      if (UporDown === "up") {
        if (index &lt; 20) {
          return index % 2 === 0 ? index / 2 : (index - 1) / 2;
        } else {
          return index % 2 === 0 ? (index + 2) / 2 : (index + 1) / 2;
        }
      } else if (UporDown === "down") {
        if (index &lt; 16) {
          return index % 2 === 0 ? (index + 2) / 2 : (index + 1) / 2;
        } else {
          return index % 2 === 0 ? (index + 4) / 2 : (index + 3) / 2;
        }
      } else if (UporDown === "ring") {
        if (index &lt; 4) {
          return index % 2 === 0 ? index / 2 : (index - 1) / 2;
        } else if (index > 3 &amp;&amp; index &lt; 12) {
          return index % 2 === 0 ? (index + 12) / 2 : (index + 11) / 2;
        } else {
          return index % 2 === 0 ? (index + 24) / 2 : (index + 23) / 2;
        }
      }
    })();

    // Check if the retention is being added to the correct side of the undercut
    const isCorrectSide =
      (selectedUnderCut[adjustIndex] &amp;&amp; index % 2 === 0) ||
      (!selectedUnderCut[adjustIndex] &amp;&amp; index % 2 === 1);

    // Validate if the retention is being added to the correct tooth based on its position
    const correctTeeth = (() => {
      if (selectedTeethbyRest &lt; 5) {
        return selectedTeethbyRest === adjustIndex; // Upper left molars + premolars
      } else if (selectedTeethbyRest > 10 &amp;&amp; selectedTeethbyRest &lt; 22) { // Upper right and lower right molars + premolars
        return selectedTeethbyRest - 6 === adjustIndex;
      } else if (selectedTeethbyRest > 26 &amp;&amp; selectedTeethbyRest &lt; 32) { // Lower left molars + premolars
        return selectedTeethbyRest - 12 === adjustIndex; 
      }
    })();

    // Condition to prevent ring clasp addition on specific teeth
    const ringteethmissing =
      (((selectedTeethbyRest === 1 || selectedTeethbyRest === 17) &amp;&amp;
        !selectedTeeth[selectedTeethbyRest - 1]) ||
        ((selectedTeethbyRest === 14 || selectedTeethbyRest === 30) &amp;&amp;
          !selectedTeeth[selectedTeethbyRest + 1])) &amp;&amp;
      selectRetention.occlusallyType === "ring";

    // If all conditions are met, toggle the retention for the selected tooth
    if (isCorrectSide &amp;&amp; isRestselect &amp;&amp; correctTeeth &amp;&amp; !ringteethmissing) {
      
      // Check if the retention type matches with the selected retention type
      const retentionTypeMatches =
        (selectRetention.retentionType === "occlusally" &amp;&amp;
          selectRetention.occlusallyType === "ring" &amp;&amp;
          Ring.array.includes(retentionImage)) ||
        (selectRetention.retentionType === "occlusally" &amp;&amp;
          selectRetention.occlusallyType === "circumferential" &amp;&amp;
          Circumferential.array.includes(retentionImage)) ||
        (selectRetention.retentionType === gingivally.type &amp;&amp;
          gingivally.array.includes(retentionImage));
          
      // Toggle the visibility of retention if the type matches
      if (retentionTypeMatches) {
        retentionArray[index] = !retentionArray[index];
      } else {
        // Error handling for adding a different kind of retention after choosing one type
        toast.error(
          "Error: You can only select " +
            selectRetention.retentionType +
            " retentions."
        );
      }
    } else {
      // Error handling for invalid conditions
      if (!isCorrectSide) {
        toast.error(
          "Error: Retention must be added to the correct side of the undercut."
        );
      } else if (!isRestselect) {
        toast.error("Error: You must select a start point.");
      } else if (!correctTeeth) {
        toast.error("Error: Add retention to the correct tooth.");
      } else if (ringteethmissing) {
        toast.error("Error: You can't add a ring clasp to this tooth.");
      }
    }

    return newState;
  });
};

/**
 * Resets the selection state when selected retention changes.
 */
useEffect(() => {
  setRestselect(false);
  setselectedTeethbyRest(null);
}, [selectedRetention]);

/**
 * Updates the z-index of retention types when the selected retention type changes.
 */
useEffect(() => {
  setZindex({ up: 4, down: 4, ring: 4 });
}, [selectRetention.retentionType]);

/**
 * Adjusts the index based on the direction (in or out) for undercut processing.
 * 
 * @param {number} index - The current index.
 * @param {string} label - Direction label ("in" or "out").
 * @returns {number} - The adjusted index.
 */
const indexExchangeforUndercut = (index, label) => {
  if (label === "in") {
    if (index >= 0 &amp;&amp; index &lt; 5) {
      index = index;
    } else if (4 &lt; index &amp;&amp; index &lt; 15) {
      index = index + 6;
    } else {
      index = index + 12;
    }
  } else {
    if (index > 19 &amp;&amp; index &lt; 25) {
      index = index - 20;
    } else if (24 &lt; index &amp;&amp; index &lt; 35) {
      index = index - 14;
    } else {
      index = index - 8;
    }
  }
  return index;
};

  useEffect(() => {
    setRestselect(false);
    setselectedTeethbyRest(null);
    setfirstbuttoncliked(Array(32).fill(false));
  }, [selectedClasps, selectedGingivally]);

  /**
  * Function to handle when a clasp is clicked.
  *
  * This function updates the state of selected clasps based on the index of the clicked tooth,
  * ensuring the clasp is properly added to either the upper or lower array, depending on the provided "UporDown" argument.
  * It also checks the tooth position (adjustIndex), verifies if there's already retention on the opposite side,
  * and ensures the clasp can only be added to the correct teeth based on the selected tooth and rest points.
  *
  * @param {number} index - The index of the clicked tooth, which determines where to add the clasp in the clasp array.
  * @param {string} UporDown - Specifies whether the clasp should be added to the upper ("up") or lower ("down") side of teeth.
  *
  * The function does the following:
  * 
  * 1. Clones the current state of selected clasps.
  * 2. Retrieves the correct clasp image from either the upper or lower set of clasp images based on the "UporDown" argument.
  * 3. Adjusts the index (adjustIndex) to correspond to the real tooth position.
  *    - For upper teeth: handles teeth positions below index 20.
  *    - For lower teeth: handles teeth positions below index 16.
  * 4. Checks if there's already a retention clasp on the opposite side of the selected tooth.
  * 5. Determines whether the clasp is being added to the correct teeth by comparing with `selectedTeethbyRest`.
  * 6. If all conditions are met (correct teeth, no clasp on the opposite side, rest selected, etc.):
  *    - Toggles the clasp state on the corresponding index.
  * 7. If any of the conditions are violated (e.g., retention on the same side, no opposite side retention, incorrect teeth, etc.):
  *    - Displays an appropriate error message using `toast.error()`.
  *
  * Error cases:
  * - If a retention already exists on the same side as the clasp being added, display an error.
  * - If retention hasn't been added to the opposite side yet, display an error.
  * - If the rest point has not been selected, display an error.
  * - If the clasp is being added to an incorrect tooth, display an error.
  *
  * @returns {object} newState - The updated state of clasps (upper or lower) with the new clasp added or errors handled.
  */
const handleClaspClick = (index, UporDown) => {
  setSelectedClasp((prevState) => {
      const newState = { ...prevState };
      const claspImage =
          UporDown === "up" ? ClaspUpImages[index] : ClaspDownImages[index];

      const claspArray =
          UporDown === "up" ? newState.upClasp1 : newState.downClasp1;

      // Calculate the adjusted index based on the tooth position
      const adjustIndex = (() => {
          if (UporDown === "up") {
              if (index &lt; 20) {
                  return index % 2 === 0 ? index / 2 : (index - 1) / 2;
              } else {
                  return index % 2 === 0 ? (index + 2) / 2 : (index + 1) / 2;
              }
          } else if (UporDown === "down") {
              if (index &lt; 16) {
                  return index % 2 === 0 ? (index + 2) / 2 : (index + 1) / 2;
              } else {
                  return index % 2 === 0 ? (index + 4) / 2 : (index + 3) / 2;
              }
          }
      })();

      // Check if there's already a retention clasp on the opposite side of the selected tooth
      const oppositeSideIndex = index % 2 === 0 ? index + 1 : index - 1;
      console.log(
          "adjusted :",
          adjustIndex,
          "index :",
          index,
          "oppositeSideIndex :",
          oppositeSideIndex
      );
      const oppositeSideRetention =
          UporDown === "up"
              ? selectedRetention.upClasp[oppositeSideIndex]
              : selectedRetention.downClasp[oppositeSideIndex];
      console.log(
          "adjusted :",
          adjustIndex,
          "index :",
          index,
          "oppositeSideIndex :",
          oppositeSideIndex,
          "oppositeSideRetention :",
          oppositeSideRetention
      );
      const isOppositeSideRetentionPresent = oppositeSideRetention === true;

      // Check if the clasp is being added to the correct teeth based on the rest point
      const correctTeeth = (() => {
          if (selectedTeethbyRest &lt; 5) {
              return selectedTeethbyRest === adjustIndex;
          } else if (selectedTeethbyRest > 10 &amp;&amp; selectedTeethbyRest &lt; 21) {
              return selectedTeethbyRest - 6 === adjustIndex;
          } else if (selectedTeethbyRest > 26 &amp;&amp; selectedTeethbyRest &lt; 32) {
              return selectedTeethbyRest - 12 === adjustIndex;
          }
      })();

      // Handle clasp selection and potential errors
      if (isOppositeSideRetentionPresent &amp;&amp; isRestselect &amp;&amp; correctTeeth) {
          if (
              (!claspArray[oppositeSideIndex] &amp;&amp;
                  ClaspUpImages.includes(claspImage)) ||
              (!claspArray[oppositeSideIndex] &amp;&amp;
                  ClaspDownImages.includes(claspImage))
          ) {
              claspArray[index] = !claspArray[index];
          }
      } else {
          if (
              UporDown === "up"
                  ? selectedRetention.upClasp[index]
                  : selectedRetention.downClasp[index]
          ) {
              toast.error(
                  "Error: Clasp cannot be added to the same side as an existing retention."
              );
          } else if (!isOppositeSideRetentionPresent) {
              toast.error(
                  "Error: You must add the retention to the opposite side first."
              );
          } else if (!isRestselect) {
              toast.error("Error: You must select a start point.");
          } else {
              toast.error("Error: Add clasp to the correct teeth.");
          }
      }

      return newState;
  });
};

  /**
  * `Teeth` Component
  * 
  * This component renders a dental grid interface with interactive buttons for teeth, missing teeth, gingivally, retention types, rests, plates, clasps, and undercuts. 
  * It allows users to interact with various elements of the dental model and manage their selection states.
  * 
  * The component includes:
  * - Buttons for each tooth that toggle selection state
  * - Buttons for missing teeth
  * - Buttons for gingivally-related actions
  * - Buttons for retention types (up, down, ring)
  * - Buttons for rests, plates, and clasps
  * - Buttons for undercuts
  * 
  * The visibility, opacity, and zIndex of each button are controlled based on the current state and the type of retention or selection.
  * 
  * The component also includes `useEffect` hooks to manage side effects related to state changes, such as resetting selections or adjusting zIndex.
  * 
  * @returns {JSX.Element} The rendered `Teeth` component.
  */

  return (
    &lt;div className="teethBackground2">
      {Array.from({ length: 32 }, (_, index) => (
        &lt;button
          key={index}
          className={`teeth-btn 
            ${
              selectedTeeth[index] &amp;&amp;
              !setMissingtooth &amp;&amp;
              !DentureData.missingteeth
                ? "selected"
                : ""
            }`}
          onClick={() => handleToothClick(index)}
        >
          &lt;img
            src={TeethImages[index]}
            alt={`Tooth ${index + 1}`}
            style={{
              visibility:
                (selectedTeeth[index] &amp;&amp; setMissingtooth) ||
                (DentureData.missingteeth &amp;&amp; selectedTeeth[index])
                  ? "hidden"
                  : "visible",
            }}
          />
        &lt;/button>
      ))}

      {Array.from({ length: 32 }, (_, index) => (
        &lt;button
          key={index}
          className="missingteeth-btn"
          id={`missingteeth-btn-${index + 1}`}
        >
          &lt;img
            src={MissingTeethImages[index]}
            alt={`MissingTeeth ${index + 1}`}
          />
        &lt;/button>
      ))}

      {Array.from({ length: 36 }, (_, index) => (
        &lt;div
          className="gingivally-btn-container"
          style={{ width: "0", height: "0" }}
          id={`gingivally-btn-container-${index + 1}`}
        >
          &lt;button
            className="gingivally-btn2"
            id={`gingivally-btn2-${index + 1}`}
            onClick={() => handlefirstButton(index)}
            style={{
              zIndex:
                selectRetention.retentionType === "gingivally" ? "12" : "4",
              display:
                selectRetention.retentionType === "gingivally"
                  ? "block"
                  : "none",
            }}
          >&lt;/button>
          &lt;button
            key={index}
            className={`gingivally-btn ${
              selectedGingivally[index] ? "selected" : ""
            }`}
            id={`gingivally-btn-${index + 1}`}
            onClick={() => {
              firstbuttoncliked[index] ? handleGingivallyClick(index) : "";
            }}
            style={{
              opacity: selectedGingivally[index] ? "1" : "0",
              zIndex:
                selectRetention.retentionType === "gingivally" ? "11" : "3",
              cursor:
                selectRetention.retentionType === "gingivally"
                  ? "pointer"
                  : "default",
            }}
            disabled={selectRetention.retentionType !== "gingivally"}
          >
            &lt;img
              src={gingivallyImages[index]}
              alt={`Gingivally ${index + 1}`}
            />
          &lt;/button>
        &lt;/div>
      ))}

      {Array.from({ length: 36 }, (_, index) => (
        &lt;button
          key={index}
          className={`retention-upbtn ${
            selectedRetention.upClasp[index] ? "selected" : ""
          }`}
          id={`retention-upbtn-${index + 1}`}
          onClick={() =>
            selectRetention.retentionType
              ? handleRetentionClick(index, "up")
              : ""
          }
          style={{
            zIndex: selectRetention.retentionType ? zindex.up : "4",
            opacity: selectedRetention.upClasp[index] ? "1" : "0",
            display: selectRetention.selectretention ? "block" : "none",

            cursor: zindex.up === 9 ? "pointer" : "default",
          }}
          disabled={zindex.up === 7}
        >
          &lt;img src={RetentionUpImages[index]} alt={`Retention ${index + 1}`} />
        &lt;/button>
      ))}

      {Array.from({ length: 36 }, (_, index) => (
        &lt;button
          key={index}
          className={`retention-downbtn ${
            selectedRetention[index] ? "selected" : ""
          }`}
          id={`retention-downbtn-${index + 1}`}
          onClick={() =>
            selectRetention.retentionType
              ? handleRetentionClick(index, "down")
              : ""
          }
          style={{
            zIndex: selectRetention.retentionType ? zindex.down : "4",

            opacity: selectedRetention.downClasp[index] ? "1" : "0",
            display: selectRetention.selectretention ? "block" : "none",
            cursor: zindex.down === 9 ? "pointer" : "default",
          }}
          disabled={zindex.down === 7}
        >
          &lt;img
            src={RetentionDownImages[index]}
            alt={`Retention ${index + 1}`}
          />
        &lt;/button>
      ))}

      {Array.from({ length: 16 }, (_, index) => (
        &lt;button
          key={index}
          className={`retention-ringbtn ${
            selectedRetention[index] ? "selected" : ""
          }`}
          id={`retention-ringbtn-${index + 1}`}
          onClick={() =>
            selectRetention.retentionType
              ? handleRetentionClick(index, "ring")
              : ""
          }
          style={{
            zIndex: selectRetention.retentionType ? zindex.ring : "4",

            opacity: selectedRetention.ringClasp[index] ? "1" : "0",
            display: selectRetention.selectretention ? "block" : "none",
          }}
          disabled={zindex.ring === 8}
        >
          &lt;img
            src={RetentionRingImages[index]}
            alt={`Retention ${index + 1}`}
          />
        &lt;/button>
      ))}

      {Array.from({ length: 62 }, (_, index) => (
        &lt;button
          key={index}
          className={`rest-btn ${selectedRests[index] ? "selected" : ""}`}
          id={`rest-btn-${index + 1}`}
          onClick={() => {
            handleRestClick(index);
            selectedRests[index] ? findIndexInArray(index) : "";
            selectedRests[index] ? setRestselect(true) : setRestselect(false);
          }}
          style={{
            display:
              selectRest.selectrest || addIndirectretention ? "block" : "none",
            opacity: selectedRests[index] ? "1" : "0",
          }}
        >
          &lt;img src={RestImages[index]} alt={`Rest ${index + 1}`} />
        &lt;/button>
      ))}

      {Array.from({ length: 40 }, (_, index) => (
        &lt;button
          key={index}
          className={`plate-btn ${selectedPlates[index] ? "selected" : ""}`}
          id={`plate-btn-${index + 1}`}
          onClick={() => (selectPlate.edit ? handlePlateClick(index) : "")}
          style={{
            zIndex: selectPlate.edit ? "9" : "4",
            display: selectPlate.view ? "block" : "none",
            opacity: selectedPlates[index] ? "1" : "0",
          }}
        >
          &lt;img src={PlateImages[index]} alt={`Plate ${index + 1}`} />
        &lt;/button>
      ))}

      {Array.from({ length: 36 }, (_, index) => (
        &lt;button
          key={index}
          className={`clasp-upbtn ${
            selectedClasps.upClasp1[index] ? "selected" : ""
          }`}
          id={`clasp-upbtn-${index + 1}`}
          onClick={() =>
            selectClasp.edit ? handleClaspClick(index, "up") : ""
          }
          style={{
            zIndex: selectClasp.edit ? zindex.up : "4",
            opacity: selectedClasps.upClasp1[index] ? "1" : "0",
            display: selectClasp.view ? "block" : "none",
          }}
          disabled={zindex.up === 7}
        >
          &lt;img src={ClaspUpImages[index]} alt={`Clasp ${index + 1}`} />
        &lt;/button>
      ))}

      {Array.from({ length: 36 }, (_, index) => (
        &lt;button
          key={index}
          className={`clasp-downbtn ${
            selectedClasps.downClasp1[index] ? "selected" : ""
          }`}
          id={`clasp-downbtn-${index + 1}`}
          onClick={() =>
            selectClasp.edit ? handleClaspClick(index, "down") : ""
          }
          style={{
            zIndex: selectClasp.edit ? zindex.down : "4",
            opacity: selectedClasps.downClasp1[index] ? "1" : "0",
            display: selectClasp.view ? "block" : "none",
          }}
          disabled={zindex.down === 7}
        >
          &lt;img src={ClaspDownImages[index]} alt={`Clasp ${index + 1}`} />
        &lt;/button>
      ))}

      {Array.from({ length: 20 }, (_, index) => (
        &lt;div key={index} className="undercut-container">
          &lt;button
            className={`undercut-btn`}
            id={`undercut-btn-${index + 1}`}
            onClick={() => (value.canEdit ? handleUndercutClick(index) : "")}
            style={{
              display:
                selectedUnderCut[index] &amp;&amp; value.visible ? "block" : "none",
            }}
          >
            &lt;img
              src={UndercutsImages[index]}
              alt={`Undercut ${index + 1}`}
              style={{
                display: selectedTeeth[indexExchangeforUndercut(index, "in")]
                  ? "none"
                  : "block",
              }}
            />
          &lt;/button>
          &lt;button
            className={`undercut-btn ${
              !selectedUnderCut[index] ? "selected" : ""
            }`}
            id={`undercut-btn-${index + 21}`}
            onClick={() => (value.canEdit ? handleUndercutClick(index) : "")}
            style={{
              display:
                !selectedUnderCut[index] &amp;&amp; value.visible ? "block" : "none",
            }}
          >
            &lt;img
              src={UndercutsImages[index + 20]}
              alt={`Undercut ${index + 20}`}
              style={{
                display: selectedTeeth[
                  indexExchangeforUndercut(index + 20, "out")
                ]
                  ? "none"
                  : "block",
              }}
            />
          &lt;/button>
        &lt;/div>
      ))}
      &lt;ToastContainer
        position="top-center"
        autoClose={2000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
        theme="dark"
        transition={Bounce}
      />
    &lt;/div>
  );
};

export default Teeth;
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>